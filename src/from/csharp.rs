use crate::interface;
use crate::from::writer::FromWriter;

use std::collections::HashMap;
use std::fs::File;
use std::io::{BufWriter, Write};

pub struct CsharpWriter;

impl FromWriter for CsharpWriter {
    
    fn file_extension(&self) -> String { "cs".to_string() }

    fn write(&mut self, writer: &mut BufWriter<File>, interface: &interface::Interface) {

        let mut indentation = 0;

        macro_rules! write {
            () => {{
                writer.write("\n".as_bytes()).unwrap();
            }};
            ("{") => {{
                write!("{ ");
                indentation = indentation + 1;
            }};
            ("}") => {{
                indentation = indentation - 1;
                write!("} ");
            }};
            ($text:expr) => {{
                writer.write(" ".repeat(4 * indentation).as_bytes()).unwrap();
                writer.write($text.as_bytes()).unwrap();
                write!();
            }};
            ($text:expr, $($args:expr),*) => {{
                writer.write(" ".repeat(4 * indentation).as_bytes()).unwrap();
                writer.write(format!($text, $($args), *).as_bytes()).unwrap();
                write!();
            }}
        }

        let mut types: HashMap<String, interface::Type> = HashMap::new();
        interface::get_types_map(&mut types, interface);

        write!("// Autogenerated by FFIDJI");

        write!();
        write!("using System;");
        write!("using System.Runtime.InteropServices;");

        write!();
        write!("using int8 = sbyte;");
        write!("using uint8 = byte;");
        write!("using int16 = Int16;");
        write!("using uint16 = UInt16;");
        write!("using int32 = Int32;");
        write!("using uint32 = UInt32;");
        write!("using int64 = Int64;");
        write!("using uint64 = UInt64;");
        write!("using float32 = float;");
        write!("using float64 = double;");
        
        write!();
        write!("namespace {}", match &interface.namespace { Some(n) => n, None => "FFIDJI" }); // Could use unwrap_or() ?
        write!("{");
        write!("public static class {}", match &interface.name { Some(n) => n, None => "MyInterface" });
        write!("{");

        write!("public const string LIBRARY_NAME = \"MyLibrary.dll\";");

        for r#type in &interface.types {
            if r#type.blittable.unwrap_or(false) {
                continue;
            }

            write!();
            write!("[StructLayout(LayoutKind.Sequential)]");
            write!("public struct {}", r#type.name);
            write!("{");
            for field in &r#type.fields {
                if field.description.is_some() {
                    write!("// {}", field.description.as_ref().unwrap());
                }
                write!("public {} {};", field.r#type, field.name);
            }
            write!("}");
        }

        // Write methods
        for method in &interface.methods {
            let parameters = &method.parameters;
            let parameters_str = parameters
                .into_iter()
                .map(|p| [p.r#type.clone(), p.name.clone()].join(" "))
                .collect::<Vec<String>>()
                .join(", ");

            write!();
            write!("[DllImport(LIBRARY_NAME)]");
            write!("public static void {}({})", method.name, parameters_str);
            write!("{");
            write!("}");
        }

        write!("}");
        write!("}");
    }
}