use crate::interface::{Interface as Interface};
use crate::to::writer::ToWriter;

use std::fs::File;
use std::io::{BufWriter, Write};

pub struct CWriter;

impl ToWriter for CWriter {
    
    fn file_extension(&self) -> String { "h".to_string() }

    fn write(&mut self, writer: &mut BufWriter<File>, interface: &Interface) {

        let mut indentation = 0;

        macro_rules! write {
            () => {{
                writer.write("\n".as_bytes()).unwrap();
            }};
            ("{") => {{
                write!("{ ");
                indentation = indentation + 1;
            }};
            ("}") => {{
                indentation = indentation - 1;
                write!("} ");
            }};
            ($text:expr) => {{
                writer.write(" ".repeat(4 * indentation).as_bytes()).unwrap();
                writer.write($text.as_bytes()).unwrap();
                write!();
            }};
            ($text:expr, $($args:expr),*) => {{
                writer.write(" ".repeat(4 * indentation).as_bytes()).unwrap();
                writer.write(format!($text, $($args), *).as_bytes()).unwrap();
                write!();
            }}
        }

        macro_rules! param_name {
            ($param:expr) => {{
                let return_type = $param;
                let mut return_type_name = return_type.r#type.clone();
                if return_type.array.unwrap_or(false) {
                    return_type_name = return_type_name + "[]";
                } else if !interface.is_param_blittable(&return_type) {
                    return_type_name = return_type_name + "_FFI";
                }
                return_type_name
            }}
        }

        macro_rules! param_name_or_ptr {
            ($param:expr) => {{
                let return_type = $param;
                let mut return_type_name = return_type.r#type.clone();
                if return_type.array.unwrap_or(false) {
                    return_type_name = format!("Arr<{}>", return_type_name);
                } else if !interface.is_param_blittable(&return_type) {
                    return_type_name = "IntPtr".to_string();
                }
                return_type_name
            }}
        }

        write!("// Autogenerated by FFIDJI");
        write!();

        write!("#include <stdint.h>");

        write!();
        write!("#ifdef __cplusplus");
        write!("extern \"C\"");
        write!("{ ");
        write!("#endif");

        write!();
        write!("typedef int8_t int8;");
        write!("typedef uint8_t uint8;");
        write!("typedef int16_t int16;");
        write!("typedef uint16_t uint16;");
        write!("typedef int32_t int32;");
        write!("typedef uint32_t uint32;");
        write!("typedef long int64;");
        write!("typedef unsigned long uint64;");
        write!("typedef float float32;");
        write!("typedef double float64;");

        for r#type in &interface.types
        {
            if r#type.base_type
            {
                continue;
            }

            // FFI type and conversions (if not blittable)
            write!();
            write!("struct {}", r#type.name);
            write!("{");
            for field in &r#type.fields
            {
                if field.array.unwrap_or(false) {
                    write!("{}* {}_ptr;", field.r#type, field.name);
                    write!("int {}_len;", field.name);
                } else {
                    write!("{} {};", field.r#type, field.name);
                }
            }
            indentation = indentation - 1;
            write!("};");
        }

        for method in &interface.methods {
            let parameters = &method.parameters;
            let parameters_str = parameters
                .into_iter()
                .map(|p| [p.r#type.clone(), p.name.clone()].join(" "))
                .collect::<Vec<String>>()
                .join(", ");

            let mut return_type_name = String::from("void");
            if method.returns.len() != 0 {
                let return_type = &method.returns[0];
                return_type_name = param_name!(return_type);
            }

            write!();
            write!("__declspec(dllimport) {} {}({});", return_type_name, method.name, parameters_str);
        }

        write!();
        write!("#ifdef __cplusplus");
        write!("} ");
        write!("#endif");
    }
}