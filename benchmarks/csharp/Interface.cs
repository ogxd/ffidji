// Autogenerated by FFIDJI

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Security;
using System.Text;

using char16 = System.Char;
using int8 = System.SByte;
using uint8 = System.Byte;
using int16 = System.Int16;
using uint16 = System.UInt16;
using int32 = System.Int32;
using uint32 = System.UInt32;
using int64 = System.Int64;
using uint64 = System.UInt64;
using float16 = System.Half;
using float32 = System.Single;
using float64 = System.Double;

namespace FFIDJI
{ 
    public static class InterfaceStrings
    { 
        public const string LIBRARY_NAME = "benchmark_interface.dll";

        private readonly struct Arr<T>
        { 
            public readonly IntPtr ptr;
            public readonly int size;
            public Arr(IntPtr ptr, int size)
            { 
                this.ptr = ptr;
                this.size = size;
            } 
        } 

        private unsafe static T[] CopyArray<T>(IntPtr ptr, int size) where T : unmanaged
        { 
            int length = size * sizeof(T);
            T[] array = new T[size];
            void* u_src = ptr.ToPointer();
            fixed (T* u_dst = &array[0])
            { 
                Unsafe.CopyBlock(u_dst, u_src, (uint)length);
            } 
            return array;
        } 

        private static T[] Convert<T>(Arr<T> arr) where T : unmanaged
        { 
            return CopyArray<T>(arr.ptr, arr.size);
        } 

        private static T Convert<T>(T obj) where T : unmanaged
        { 
            return obj;
        } 

        [SuppressUnmanagedCodeSecurity]
        [DllImport(LIBRARY_NAME, EntryPoint = "Alloc_FFI")]
        private static extern IntPtr Alloc(int length);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(LIBRARY_NAME, EntryPoint = "Free_FFI")]
        private static extern void Free(IntPtr ptr, int length);

        private static unsafe void Free<T>(Arr<T> input) where T : unmanaged
        { 
            Free(input.ptr, input.size * sizeof(T));
        } 

        [StructLayout(LayoutKind.Sequential)]
        public struct strings
        { 
            public string[] array;
        } 

        [StructLayout(LayoutKind.Sequential)]
        private struct strings_FFI
        { 
            public Arr<string_FFI> array;
        } 

        private static unsafe void Free(strings_FFI input)
        { 
            for (int i = 0; i < input.array.size; i++)
            { 
                Free(((string_FFI*)input.array.ptr)[i]);
            } 
            Free(input.array);
        } 

        private static strings Convert(strings_FFI data_FFI)
        { 
            return new strings
            { 
                array = Convert(data_FFI.array),
            };
        } 

        private static strings_FFI Convert(strings data)
        { 
            return new strings_FFI
            { 
                array = Convert(data.array),
            };
        } 

        private unsafe static strings[] Convert(Arr<strings_FFI> arr)
        { 
            var array_ffi = CopyArray<strings_FFI>(arr.ptr, arr.size);
            var array = new strings[arr.size];
            for (int i = 0; i < arr.size; ++i) array[i] = Convert(array_ffi[i]);
            return array;
        } 

        private unsafe static Arr<strings_FFI> Convert(strings[] array)
        { 
            IntPtr ptr = Alloc(array.Length * sizeof(strings_FFI));
            strings_FFI* u_dst = (strings_FFI*)ptr.ToPointer();
            for (int i = 0; i < array.Length; ++i) u_dst[i] = Convert(array[i]);
            return new Arr<strings_FFI>(ptr, array.Length);
        } 

        [StructLayout(LayoutKind.Sequential)]
        private struct string_FFI
        { 
            public Arr<int8> utf8bytes;
        } 

        private static unsafe void Free(string_FFI input)
        { 
            Free(input.utf8bytes.ptr, input.utf8bytes.size * sizeof(int8));
        } 

        private static string Convert(string_FFI data_FFI)
        { 
            unsafe
            { 
                byte* pStringUtf8 = (byte*)data_FFI.utf8bytes.ptr;
                var len = 0;
                while (pStringUtf8[len] != 0) len++; // Todo: not needed since we have size
                return Encoding.UTF8.GetString(pStringUtf8, len);
            } 
        } 

        private static string_FFI Convert(string data)
        { 
            unsafe
            { 
                fixed (char* pInput = data)
                { 
                    var len = Encoding.UTF8.GetByteCount(pInput, data.Length);
                    var pResult = (byte*)Alloc(len + 1).ToPointer();
                    var bytesWritten = Encoding.UTF8.GetBytes(pInput, data.Length, pResult, len);
                    pResult[len] = 0; // null terminated
                    return new string_FFI { utf8bytes = new Arr<sbyte>((IntPtr)pResult, len + 1) };
                } 
            } 
        } 

        private unsafe static string[] Convert(Arr<string_FFI> arr)
        { 
            var array_ffi = CopyArray<string_FFI>(arr.ptr, arr.size);
            var array = new string[arr.size];
            for (int i = 0; i < arr.size; ++i) array[i] = Convert(array_ffi[i]);
            return array;
        } 

        private unsafe static Arr<string_FFI> Convert(string[] array)
        { 
            IntPtr ptr = Alloc(array.Length * sizeof(string_FFI));
            string_FFI* u_dst = (string_FFI*)ptr.ToPointer();
            for (int i = 0; i < array.Length; ++i) u_dst[i] = Convert(array[i]);
            return new Arr<string_FFI>(ptr, array.Length);
        } 

        [SuppressUnmanagedCodeSecurity]
        [DllImport(LIBRARY_NAME, EntryPoint = "Concat")]
        private extern static string_FFI Concat_FFI(string_FFI a, string_FFI b);

        public static string Concat(string a, string b)
        { 
            var a_ffi = Convert(a);
            var b_ffi = Convert(b);
            var result_ffi = Concat_FFI(a_ffi, b_ffi);
            Free(a_ffi);
            Free(b_ffi);
            var result = Convert(result_ffi);
            Free(result_ffi);
            return result;
        } 

        [SuppressUnmanagedCodeSecurity]
        [DllImport(LIBRARY_NAME, EntryPoint = "ConcatOptimized")]
        private extern static string_FFI ConcatOptimized_FFI(string_FFI a, string_FFI b);

        public static string ConcatOptimized(string a, string b)
        { 
            var a_ffi = Convert(a);
            var b_ffi = Convert(b);
            var result_ffi = ConcatOptimized_FFI(a_ffi, b_ffi);
            Free(a_ffi);
            Free(b_ffi);
            var result = Convert(result_ffi);
            Free(result_ffi);
            return result;
        } 
    } 
} 
