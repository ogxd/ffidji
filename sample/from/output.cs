// Autogenerated by FFIDJI

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

using int8 = System.SByte;
using uint8 = System.Byte;
using int16 = System.Int16;
using uint16 = System.UInt16;
using int32 = System.Int32;
using uint32 = System.UInt32;
using int64 = System.Int64;
using uint64 = System.UInt64;
using float16 = System.Half;
using float32 = System.Single;
using float64 = System.Double;

namespace FFIDJI
{ 
    public static class SampleInterface
    { 
        public const string LIBRARY_NAME = "MyNativeLibrary.dll";

        private readonly struct Arr<T>
        { 
            public readonly IntPtr ptr;
            public readonly int size;
            public Arr(IntPtr ptr, int size)
            { 
                this.ptr = ptr;
                this.size = size;
            } 
        } 

        private unsafe static T[] CopyArray<T>(IntPtr ptr, int size) where T : unmanaged
        { 
            int length = size * Marshal.SizeOf<T>();
            T[] array = new T[size];
            GCHandle handle = GCHandle.Alloc(array, GCHandleType.Pinned);
            void* u_ptr = ptr.ToPointer();
            void* u_dst = handle.AddrOfPinnedObject().ToPointer();
            Unsafe.CopyBlock(u_ptr, u_dst, (uint)length);
            handle.Free();
            return array;
        } 

        private static T[] Convert<T>(Arr<T> arr) where T : unmanaged
        { 
            return CopyArray<T>(arr.ptr, arr.size);
        } 

        private static T Convert<T>(T obj) where T : unmanaged
        { 
            return obj;
        } 

        private unsafe static Arr<T> Convert<T>(T[] arr) where T : unmanaged
        { 
            int length = arr.Length * Marshal.SizeOf<T>();
            IntPtr ptr = Marshal.AllocHGlobal(length);
            GCHandle handle = GCHandle.Alloc(arr, GCHandleType.Pinned);
            void* u_dst = ptr.ToPointer();
            void* u_ptr = handle.AddrOfPinnedObject().ToPointer();
            Unsafe.CopyBlock(u_ptr, u_dst, (uint)length);
            handle.Free();
            return new Arr<T>(ptr, arr.Length);
        } 

        [StructLayout(LayoutKind.Sequential)]
        public struct MyBlittableStruct
        { 
            public int32 foo;
            public int32 bar;
        } 

        [StructLayout(LayoutKind.Sequential)]
        public struct MyNonBlittableStruct
        { 
            public int32[] fooArray;
            public int32[] barArray;
        } 

        [StructLayout(LayoutKind.Sequential)]
        private struct MyNonBlittableStruct_FFI
        { 
            public Arr<int32> fooArray;
            public Arr<int32> barArray;
        } 

        private static MyNonBlittableStruct Convert(MyNonBlittableStruct_FFI data_FFI)
        { 
            return new MyNonBlittableStruct
            { 
                fooArray = Convert(data_FFI.fooArray),
                barArray = Convert(data_FFI.barArray),
            };
        } 

        private static MyNonBlittableStruct_FFI Convert(MyNonBlittableStruct data)
        { 
            return new MyNonBlittableStruct_FFI
            { 
                fooArray = Convert(data.fooArray),
                barArray = Convert(data.barArray),
            };
        } 

        private unsafe static MyNonBlittableStruct[] Convert(Arr<MyNonBlittableStruct_FFI> arr)
        { 
            var array_ffi = CopyArray<MyNonBlittableStruct_FFI>(arr.ptr, arr.size);
            var array = new MyNonBlittableStruct[arr.size];
            for (int i = 0; i < arr.size; ++i) array[i] = Convert(array_ffi[i]);
            return array;
        } 

        [DllImport(LIBRARY_NAME)]
        private extern static int32 Add(int32 A, int32 B);

        public static int32 Add1(int32 A, int32 B)
        { 
            return Convert(Add(Convert(A), Convert(B)));
        } 
    } 
} 
