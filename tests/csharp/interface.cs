// Autogenerated by FFIDJI

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Security;

using char16 = System.Char;
using int8 = System.SByte;
using uint8 = System.Byte;
using int16 = System.Int16;
using uint16 = System.UInt16;
using int32 = System.Int32;
using uint32 = System.UInt32;
using int64 = System.Int64;
using uint64 = System.UInt64;
using float16 = System.Half;
using float32 = System.Single;
using float64 = System.Double;

namespace FFIDJI
{ 
    public static class SampleInterface
    { 
        public const string LIBRARY_NAME = "MyNativeLibrary.dll";

        private readonly struct Arr<T>
        { 
            public readonly IntPtr ptr;
            public readonly int size;
            public Arr(IntPtr ptr, int size)
            { 
                this.ptr = ptr;
                this.size = size;
            } 
        } 

        private unsafe static T[] CopyArray<T>(IntPtr ptr, int size) where T : unmanaged
        { 
            int length = size * sizeof(T);
            T[] array = new T[size];
            void* u_src = ptr.ToPointer();
            fixed (T* u_dst = &array[0])
            { 
                Unsafe.CopyBlock(u_dst, u_src, (uint)length);
            } 
            return array;
        } 

        private static T[] Convert<T>(Arr<T> arr) where T : unmanaged
        { 
            return CopyArray<T>(arr.ptr, arr.size);
        } 

        private static T Convert<T>(T obj) where T : unmanaged
        { 
            return obj;
        } 

        private unsafe static Arr<T> Convert<T>(T[] array) where T : unmanaged
        { 
            return Convert(new ReadOnlySpan<T>(array));
        } 

        private unsafe static Arr<T> Convert<T>(ReadOnlySpan<T> array) where T : unmanaged
        { 
            int length = array.Length * sizeof(T);
            IntPtr ptr = Alloc(length);
            void* u_dst = ptr.ToPointer();
            fixed (T* u_src = &array[0])
            { 
                Unsafe.CopyBlock(u_dst, u_src, (uint)length);
            } 
            return new Arr<T>(ptr, array.Length);
        } 

        [SuppressUnmanagedCodeSecurity]
        [DllImport(LIBRARY_NAME, EntryPoint = "Alloc_FFI")]
        private static extern IntPtr Alloc(int length);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(LIBRARY_NAME, EntryPoint = "Free_FFI")]
        private static extern void Free(IntPtr ptr, int length);

        [StructLayout(LayoutKind.Sequential)]
        public struct Profiler
        { 
            // false
            public string name;
            // false
            public string description;
            // false
            public int32 id;
        } 

        [StructLayout(LayoutKind.Sequential)]
        private struct Profiler_FFI
        { 
            public string_FFI name;
            public string_FFI description;
            public int32 id;
        } 

        private static unsafe void Free(Profiler_FFI input)
        { 
            Free(input.name);
            Free(input.description);
        } 

        private static Profiler Convert(Profiler_FFI data_FFI)
        { 
            return new Profiler
            { 
                name = Convert(data_FFI.name),
                description = Convert(data_FFI.description),
                id = data_FFI.id,
            };
        } 

        private static Profiler_FFI Convert(Profiler data)
        { 
            return new Profiler_FFI
            { 
                name = Convert(data.name),
                description = Convert(data.description),
                id = Convert(data.id),
            };
        } 

        private unsafe static Profiler[] Convert(Arr<Profiler_FFI> arr)
        { 
            var array_ffi = CopyArray<Profiler_FFI>(arr.ptr, arr.size);
            var array = new Profiler[arr.size];
            for (int i = 0; i < arr.size; ++i) array[i] = Convert(array_ffi[i]);
            return array;
        } 

        [StructLayout(LayoutKind.Sequential)]
        public struct Profilers
        { 
            // true
            public Profiler[] profilers;
        } 

        [StructLayout(LayoutKind.Sequential)]
        private struct Profilers_FFI
        { 
            public Arr<Profiler> profilers;
        } 

        private static unsafe void Free(Profilers_FFI input)
        { 
            for (int i = 0; i < input.profilers.size; i++)
            { 
                Free(input.profilers.ptr[i]);
            } 
            Free(input.profilers);
        } 

        private static Profilers Convert(Profilers_FFI data_FFI)
        { 
            return new Profilers
            { 
                profilers = Convert(data_FFI.profilers),
            };
        } 

        private static Profilers_FFI Convert(Profilers data)
        { 
            return new Profilers_FFI
            { 
                profilers = Convert(data.profilers),
            };
        } 

        private unsafe static Profilers[] Convert(Arr<Profilers_FFI> arr)
        { 
            var array_ffi = CopyArray<Profilers_FFI>(arr.ptr, arr.size);
            var array = new Profilers[arr.size];
            for (int i = 0; i < arr.size; ++i) array[i] = Convert(array_ffi[i]);
            return array;
        } 

        [StructLayout(LayoutKind.Sequential)]
        private struct string_FFI
        { 
            public Arr<char16> utf16_char;
        } 

        private static unsafe void Free(string_FFI input)
        { 
            Free(input.utf16_char.ptr, input.utf16_char.size * sizeof(char16));
        } 

        private static string Convert(string_FFI data_FFI)
        { 
            unsafe
            { 
                return new string((char*)data_FFI.utf16_char.ptr);
            } 
        } 

        private static string_FFI Convert(string data)
        { 
            return new string_FFI
            { 
                utf16_char = Convert(data.AsSpan())
            };
        } 

        private unsafe static string[] Convert(Arr<string_FFI> arr)
        { 
            var array_ffi = CopyArray<string_FFI>(arr.ptr, arr.size);
            var array = new string[arr.size];
            for (int i = 0; i < arr.size; ++i) array[i] = Convert(array_ffi[i]);
            return array;
        } 

        [SuppressUnmanagedCodeSecurity]
        [DllImport(LIBRARY_NAME, EntryPoint = "GetAvailableProfilers")]
        private extern static Profilers GetAvailableProfilers_FFI();

        public static Profilers GetAvailableProfilers()
        { 
            var result_ffi = GetAvailableProfilers_FFI();
            var result = Convert(result_ffi);
            Free(result_ffi);
            return result;
        } 
    } 
} 
